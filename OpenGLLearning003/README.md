# Textures
Learning OpenGL On the MAC 

纹理

    为了能够把纹理映射到三角形上，我们需要指定三角形的每个顶点各自对应的纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标，用来表明该从纹理图像的哪个部分采样。之后在图形的其他片段上进行片段插值。
    
    纹理坐标在x和y上，范围为0到1之间。使用纹理坐标获取纹理颜色叫做采样。纹理坐标起始于左下角（0，0），终止与右上角（1，1）。

纹理环绕方式

    纹理坐标的范围通常是从(0, 0)到(1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像（我们基本上忽略浮点纹理坐标的整数部分），但OpenGL提供了更多的选择：
    
    GL_REPEAT  对纹理的默认行为。重复纹理图像
    GL_MIRRORED_REPEAT 和GL_REPEAT一样，但每次重复图片是镜像放置的
    GL_CLAMP_TO_EDGE 纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐           标的边缘，产生一种边缘被拉伸的效果。
    GL_CLAMP_TO_BORDER 超出的坐标为用户指定的边缘颜色。

    每个选项都可以使用glTexParameter*函数对单独的一个坐标轴设置（s、t（如果是使用3D纹理那么还有一个r）它们和x、y、z是等价的）
    
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);

    第一个参数指定了纹理目标；我们使用的是2D纹理，因此纹理目标是GL_TEXTURE_2D。第二个参数需要我们指定设置的选项与应用的纹理轴。我们打算配置的是WRAP选项，并且指定S和T轴。最后一个参数需要我们传递一个环绕方式，在这个例子中OpenGL会给当前激活的纹理设定纹理环绕方式为GL_MIRRORED_REPEAT。
    
纹理过滤

    纹理坐标不依赖于分辨率。所以OpenGL需要知道怎样将纹理像素(Texture Pixel，也叫Texel)映射到纹理坐标。当你有一个很大的物体但是纹理的分辨率很低的时候这就变得很重要了。你可能已经猜到了，OpenGL也有对于纹理过滤(Texture Filtering)的选项。纹理过滤有很多个选项，但是现在我们只讨论最重要的两种：GL_NEAREST和GL_LINEAR。
    
    Texture Pixel也叫Texel，你可以想象你打开一张.jpg格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素；注意不要和纹理坐标搞混，纹理坐标是你给模型顶点设置的那个数组，OpenGL以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色。

    GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色
    
    GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。
    
    进行放大(Magnify)和缩小(Minify)操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。我们需要使用glTexParameter*函数为放大和缩小指定过滤方式
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    
多级渐远纹理

     多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。
     手工为每个纹理图像创建一系列多级渐远纹理很麻烦，幸好OpenGL有一个glGenerateMipmaps函数，在创建完一个纹理后调用它OpenGL就会承担接下来的所有工作了
     
     GL_NEAREST_MIPMAP_NEAREST    使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样
     GL_LINEAR_MIPMAP_NEAREST    使用最邻近的多级渐远纹理级别，并使用线性插值进行采样
     GL_NEAREST_MIPMAP_LINEAR    在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样
     GL_LINEAR_MIPMAP_LINEAR    在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样
     
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);

应用纹理

    片段着色器也应该能访问纹理对象，但是我们怎样能把纹理对象传给片段着色器呢？GLSL有一个供纹理对象使用的内建数据类型，叫做采样器(Sampler)，它以纹理类型作为后缀，比如sampler1D、sampler3D，或在我们的例子中的sampler2D。我们可以简单声明一个uniform sampler2D把一个纹理添加到片段着色器中，稍后我们会把纹理赋值给这个uniform。

    #version 300 core
    precision mediump float;
    in vec3 ourColor;
    in vec2 TexCoord;
    out vec4 color;
    uniform sampler2D ourTexture;
    void main()
        {
            color = texture(ourTexture, TexCoord);
        }

    我们使用GLSL内建的texture函数来采样纹理的颜色，它第一个参数是纹理采样器，第二个参数是对应的纹理坐标。texture函数会使用之前设置的纹理参数对相应的颜色值进行采样。这个片段着色器的输出就是纹理的（插值）纹理坐标上的(过滤后的)颜色。
 
 一
 
     调用-(void)createTexure方法，就可以看见我们的效果了。

二

    一个纹理的位置值通常称为一个纹理单元(Texture Unit)。一个纹理的默认纹理单元是0，它是默认的激活纹理单元，所以前面部分我们没有分配一个位置值，所以也就没有使用glUniform给uniform赋值。

    纹理单元的主要目的是让我们在着色器中可以使用多个纹理，通过把纹理单元赋值给采样器，我们就可以一次绑定多个纹理，只要我们首先激活对应的纹理单元，。
    我们可以使用glActiveTexture激活纹理单元，传入我们需要使用的纹理单元
    
        glActiveTexture(GL_TEXTURE0); //在绑定纹理之前先激活纹理单元
        glBindTexture(GL_TEXTURE_2D, texture);
        
        激活纹理单元之后，接下来的glBindTexture函数调用会绑定这个纹理到当前激活的纹理单元，纹理单元GL_TEXTURE0默认总是被激活，所以我们在前面的例子里当我们使用glBindTexture的时候，无需激活任何纹理单元。
Important
        
    OpenGL至少保证有16个纹理单元供你使用，也就是说你可以激活从GL_TEXTURE0到GL_TEXTRUE15。它们都是按顺序定义的，所以我们也可以通过GL_TEXTURE0 + 8的方式获得GL_TEXTURE8，这在当我们需要循环一些纹理单元的时候会很有用。

    我们需要通过片段着色器来接收另一个采样器。
    
    调用-（void）comDoubleText方法可以就可以看见加载多个纹理的效果了。

矩阵

    使用（多个）矩阵对象可以更好的变换一个物体。
    
    
一 、向量

    向量是有方向和大小的。在高数中，用在字母上面加一横表示向量，比如说v¯。
    我们可以使用向量在2D或3D空间中表示方向与位置.
    和普通数字一样，我们也可以用向量进行多种运算（其中一些你可能已经看到过了）。
    
    运算
        1、向量和标量的运算
        
            标量(Scalar)只是一个数字（或者说是仅有一个分量的向量）。当把一个向量加/减/乘/除一个标量，我们可以简单的把向量的每个分量分别进行该运算。对于加法来说会像这样:
        
            {1,2,3} + x = {1+x,2+x,3+x};
        
            其中的+可以是+，-，·或÷，其中·是乘号。注意－和÷运算时不能颠倒（标量-/÷向量），因为颠倒的运算是没有定义的。
        
        2、向量取反
        
            对一个向量取反(Negate)会将其方向逆转。一个指向东北的向量取反后就指向西南方向了。我们在一个向量的每个分量前加负号就可以实现取反了（或者说用-1数乘该向量）
            
            -v¯ = {-x,-y,-z};
        
        3、向量加减
        
            向量的加法可以被定义为是分量的(Component-wise)相加，即将一个向量中的每一个分量加上另一个向量的对应分量：
            
            {1,2,3} + {4,5,6} = {1+4,2+5,3+6};
            
            就像普通数字的加减一样，向量的减法等于加上第二个向量的相反向量
            
            两个向量的相减会得到这两个向量指向位置的差。这在我们想要获取两点的差会非常有用。
            
        4、向量的长度
        
            我们使用勾股定理(Pythagoras Theorem)来获取向量的长度(Length)/大小(Magnitude)。如果你把向量的x与y分量画出来，该向量会和x与y分量为边形成一个三角形。
            
            有一个特殊类型的向量叫做单位向量(Unit Vector)。单位向量有一个特别的性质——它的长度是1。我们可以用任意向量的每个分量除以向量的长度得到它的单位向量n̂。
            我们把这种方法叫做一个向量的标准化(Normalizing)。单位向量头上有一个^样子的记号。通常单位向量会变得很有用，特别是在我们只关心方向不关心长度的时候（如果改变向量的长度，它的方向并不会改变）。
            
        5、向量相乘
        
            两个向量相乘是一种很奇怪的情况。普通的乘法在向量上是没有定义的，因为它在视觉上是没有意义的。但是在相乘的时候我们有两种特定情况可以选择：一个是点乘(Dot Product)，记作v¯⋅k¯v¯⋅k¯，另一个是叉乘(Cross Product)，记作v¯×k¯v¯×k¯。
            
            5.1、点乘
            
            两个向量的点乘等于它们的数乘结果乘以两个向量之间夹角的余弦值。可能听起来有点费解，我们来看一下公式：
            
            v¯⋅k¯=||v¯||⋅||k¯||⋅cosθ
            v¯⋅k¯=||v¯||⋅||k¯||⋅cos⁡θ
            它们之间的夹角记作θθ。为什么这很有用？想象如果v¯v¯和k¯k¯都是单位向量，它们的长度会等于1。这样公式会有效简化成：
            
            v¯⋅k¯=1⋅1⋅cosθ=cosθ
            v¯⋅k¯=1⋅1⋅cos⁡θ=cos⁡θ
            
            现在点积只定义了两个向量的夹角。你也许记得90度的余弦值是0，0度的余弦值是1。
            用途：
                使用点乘可以很容易测试两个向量是否正交(Orthogonal)或平行（正交意味着两个向量互为直角）
            
            点乘是通过将对应分量逐个相乘，然后再把所得积相加来计算的。两个单位向量的（你可以验证它们的长度都为1）点乘会像是这样：
            
        {0.6,-0.8,0}.{0,1,0} = (0.6*0)+(-0.8*1)+(0*0)= -0.8
        
        要计算两个单位向量间的夹角，我们可以使用反余弦函数cos−1cos−1 ，可得结果是143.1度。点乘在计算光照的时候很有用。
        
            5.2、叉乘
            
                叉乘只在3D空间中有定义，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。如果输入的两个向量也是正交的，那么叉乘之后将会产生3个互相正交的向量。
                
                {Ax,Ay,Az} x {Bx,By,Bz} = {Ay⋅Bz−Az⋅By,Az⋅Bx−Ax⋅Bz,Ax⋅By−Ay⋅Bx};
                
二、矩阵

    简而言之，矩阵就是一个矩形的数字、符号或表达式数组。矩阵中每一项叫做矩阵的元素(Element)。
    
        | 1，2，3 |
        | 4，5，6 |
        
        矩阵可以通过(i, j)进行索引，i是行，j是列，这就是上面的矩阵叫做2×3矩阵的原因（3列2行，也叫做矩阵的维度(Dimension)）。这与你在索引2D图像时的(x, y)相反，获取4的索引是(2, 1)（第二行，第一列）（译注：如果是图像索引应该是(1, 2)，先算列，再算行）

        1.1、矩阵的加减
        
        1.2、矩阵相乘
        
            相乘还有一些限制：
        
            1.2.1 只有当左侧矩阵的列数与右侧矩阵的行数相等，两个矩阵才能相乘。
            1.2.2 矩阵相乘不遵守交换律(Commutative)，也就是说A⋅B≠B⋅AA⋅B≠B⋅A。
            
            第一个矩阵的行数和第二个矩阵的列数进行乘加
            | 1  2 |    | 5 6 |   | 1.5+2.7 1.6+2.8 |
            |      |  . |     | = |                 |
            | 3  4 |    | 7 8 |   | 3.5+4.7 3.6+4.8 |
            
            结果矩阵的维度是(n, m)，n等于左侧矩阵的行数，m等于右侧矩阵的列数。
            
三、矩阵与向量相乘 （一下并没有给出详细资料，请自行查阅）

        1、单位矩阵
        
        2、缩放
        
            我们先来尝试缩放向量v¯=(3,2)v¯=(3,2)。我们可以把向量沿着x轴缩放0.5，使它的宽度缩小为原来的二分之一；我们将沿着y轴把向量的高度缩放为原来的两倍。之后变成了s¯=（1.5,4）
            
            2.1、缩放矩阵
            
        3、位移
        
            3.1、变换矩阵
            
        4、旋转
        
            4.1、旋转矩阵

四、矩阵的组合

    建议您在组合矩阵时，先进行缩放操作，然后是旋转，最后才是位移，否则它们会（消极地）互相影响
    
    使用和调用-（void）useJuz方法就可以看见效果了。
